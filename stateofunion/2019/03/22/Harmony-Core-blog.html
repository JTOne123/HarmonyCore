<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>What’s Up with Harmony Core? | Harmony Core</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="What’s Up with Harmony Core?" />
<meta name="author" content="Jeff Greene" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Harmony Core is Synergex’s open-source solution for allowing access to the data and logic in your Synergy applications." />
<meta property="og:description" content="Harmony Core is Synergex’s open-source solution for allowing access to the data and logic in your Synergy applications." />
<link rel="canonical" href="https://synergex.github.io/HarmonyCore/stateofunion/2019/03/22/Harmony-Core-blog.html" />
<meta property="og:url" content="https://synergex.github.io/HarmonyCore/stateofunion/2019/03/22/Harmony-Core-blog.html" />
<meta property="og:site_name" content="Harmony Core" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-22T13:07:00-07:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://synergex.github.io/HarmonyCore/stateofunion/2019/03/22/Harmony-Core-blog.html"},"url":"https://synergex.github.io/HarmonyCore/stateofunion/2019/03/22/Harmony-Core-blog.html","author":{"@type":"Person","name":"Jeff Greene"},"description":"Harmony Core is Synergex’s open-source solution for allowing access to the data and logic in your Synergy applications.","headline":"What’s Up with Harmony Core?","@type":"BlogPosting","dateModified":"2019-03-22T13:07:00-07:00","datePublished":"2019-03-22T13:07:00-07:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" type="image/x-icon" href="/HarmonyCore/favicon.ico">
  <link rel="stylesheet" href="/HarmonyCore/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://synergex.github.io/HarmonyCore/feed.xml" title="Harmony Core" /></head>
<body><header class="site-header stickyheader">
  <div class="wrapper"><a class="site-title" rel="author" href="/HarmonyCore/"><img src="/HarmonyCore/assets/images/HarmonyCore.png" alt="Harmony Core"></a><nav class="site-nav" style="z-index:50;">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger" style="padding-right: 50px;">
						<!-- Below will automatically display all the pages in the title. This is commented out for now, as we don't have updates or post mortems-->
          <!--<a class="page-link" href="/HarmonyCore/about/">What is Harmony Core</a><a class="page-link" href="/HarmonyCore/">Harmony Core Development Blog</a><a class="page-link" href="/HarmonyCore/meet-the-team/">Harmony Core Development Team</a><a class="page-link" href="/HarmonyCore/office-hours/">Harmony Core Office Hours</a><a class="page-link" href="/HarmonyCore/post-mortem/">Post Mortem</a><a class="page-link" href="/HarmonyCore/updates/">Updates</a>-->
			<a href="/HarmonyCore/office-hours/" class=""><span class="page-link">Office Hours</span></a>
			<a href="/HarmonyCore/meet-the-team/" class=""><span class="page-link">Meet the team</span></a>
			<a href="/HarmonyCore/about/" class=""><span class="page-link">About</span></a>
        </div>
      </nav></div>
</header>

<a href="https://github.com/Synergex/HarmonyCore" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#39566c; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>
<style>
	.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}
	.github-corner {
		position: sticky;
		top:0;
		right:0;
		z-index: 20;
	}
	@media only screen and (max-width: 800px) {
		.github-corner {
			top:58px;
			z-index: 0;
		}
	}
	.github-corner svg path {
		transition: color 0.4s;
	}
	.github-corner:hover svg path {
		color: #c1ebeb;
	}
</style>
<main class="page-content" aria-label="Content">
		<div class="wrapper">
      <div class="maincontent">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">What&#39;s Up with Harmony Core?</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-22T13:07:00-07:00" itemprop="datePublished">Mar 22, 2019
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Jeff Greene</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>by Jeff Greene, Harmony Core Product Manager</p>

<p>If you attended the 2018 Synergy DevPartner Conference in New Orleans,
you probably remember hearing about Harmony Core. <a href="https://github.com/Synergex/HarmonyCore" target="_blank" rel="noopener">Harmony
Core</a> is Synergex’s open-source
solution for allowing access to the data and logic in your Synergy
applications. We had roughly six conference sessions on this topic, so
if you weren’t at the conference or need a refresher, you can check out
the
<a href="https://www.youtube.com/playlist?list=PLP_Ryl6KlCA2-SDU7o3wgN2OO9fgaeHnD" target="_blank" rel="noopener">videos</a>.
Since then, Steve Ives and I have been working fast and furiously on our
backlog, ideas that surfaced at the conference, and adjustments to
Harmony Core based on early adopter experiences. In this post, I’ll
attempt to shed light on some of our recent decisions, struggles, and
successes. As the interim product manager for Harmony Core, I also want
to share our plans for the near future so you know what to look forward
to and what to expect from us.</p>

<h2 id="from-the-backlog">From the Backlog</h2>

<p>When we announced the release of Harmony Core at the conference, we
discussed the backlog of tasks we wanted to complete. In the months
since we shared the following slide, many of these items have been
delivered.</p>

<p><img src="/HarmonyCore/assets/2019-03-22/image1.png" alt="What's next" /></p>

<p>Later in this blog post, I’ll discuss some of the enhancements we’ve
implemented, but I’d like to start by mentioning one of the more
important changes we’ve made for optimization: <strong>implementing sparse
Select</strong>. Without this, Harmony Core could never realize its performance
potential because of the extra data sent over <em>xf</em>Server connections.
Fortunately, the implementation turned out to be fairly straightforward.
Harmony Core simply detects whether a channel is remote by using
%ISINFO. If the channel is remote, Harmony Core builds a sparse Select
object by processing the supplied EF Core LINQ expression and searching
for field and object references that are required to create the result.
If the channel is local, Harmony Core won’t build a sparse Select object
because the setup required for the object would incur a small
performance cost.</p>

<h2 id="conference-conversations">Conference Conversations</h2>

<p>At the conference, we talked with many of you about how we could improve
and extend Harmony Core. These conversations were invaluable in helping
us prioritize items in the backlog, and they got us thinking about how
we could better take advantage of open standards. One thing we started
thinking about was <strong>our custom protocol for Traditional Bridge,</strong> which
is the Harmony Core component that exposes traditional Synergy logic.
This custom protocol was well documented and made use of JSON, so it
wasn’t difficult to understand. However, <strong>it certainly seemed odd to
have something custom like this, given our focus on open standards.</strong> We
wanted to find an open solution, and as we looked around, JSON-RPC 2.0
caught our attention due to its use as the base for Microsoft’s Language
Server Protocol. Microsoft uses this protocol for remote procedure calls
across standard in/out, which is very similar to our use case. And on
further investigation, we found that there was an open-source project
that implemented JSON-RPC 2.0 in .NET Core. It’s written by Andrew
Arnott, a long time Microsoft employee with whom we’ve interacted
extensively, making this an even more enticing choice.</p>

<p>Having a top-quality high-performance library available sealed the deal,
and we set out to switch the protocol. After some limited changes to
Harmony Core server code (written in traditional Synergy) we had a
working JSON-RPC 2.0 server and were able to communicate with it using
vs-streamjsonrpc. <strong>Using someone else’s client to talk to our
traditional Synergy server gave me a great deal of confidence</strong> in our
adherence to the standard and ensured that we won’t have any weird
behavior if you want your server to interface with some other
non-Synergy system using the same mechanism. This is just one of the
many steps we’ve taken to make Harmony Core open and accessible for all
of you.</p>

<h2 id="real-world-findings">Real-World Findings</h2>

<p>Early on, a lot of our decision-making for Harmony Core was based on our
experience developing and supporting <em>xf</em>ServerPlus, <em>xf</em>ODBC, and
Symphony Harmony. Since the conference, we’ve been able to get Harmony
Core into the hands of some early adopters, which has enabled us to make
more targeted decisions based on real-world situations. We’ve learned a
lot so far, and we’re looking forward to tackling any new scenarios that
arise in the future. For now, we’ve got a solid list of improvements
that should make the implementation process even smoother for future
adopters.</p>

<h3 id="exposing-synergy-code-as-a-web-service">Exposing Synergy Code as a Web Service</h3>

<p><strong>With our first early adopter, we exposed preexisting Synergy code as a
web service.</strong> We had expected this to be a use case, but hadn’t yet
worked through all the implications for the project layout and how to
bring together all the CodeGen templates. We ended up making quite a few
changes to the project template layout and tweaks to the CodeGen batch
file included with the project template.</p>

<p>Initially, we weren’t sure whether we wanted to use .NET Framework or
.NET Core for this project. Did we need .NET Framework AppDomains for
code isolation? Or could we get away with the much more performant
AssemblyLoadContext available with .NET Core? After extensive
discussions, we determined that <strong>we needed only global/common/static
isolation, so .NET Core proved to be a perfect fit.</strong> Since we were
wrapping preexisting code that wouldn’t normally compile on .NET Core,
we needed to make a .NET Standard version of the customer’s core
libraries. This went pretty smoothly once we sprinkled a few .IFDEFs
around to remove code related to WinForms and Windows services.</p>

<p>Once everything was running, we were greeted by a debugger that was
behaving strangely. We looked at our isolated objects in the debugger,
but the debugger wouldn’t display any values, and we weren’t able to
expand any children. It turned out there was a bug in the .NET Core
debugger that prevented evaluation of objects that existed in multiple
AssemblyLoadContexts. This issue was reported to Microsoft and was fixed
(in Visual Studio 2019). <strong>This marked our first of many successful
Harmony Core implementations.</strong></p>

<h3 id="querying-with-odata">Querying with OData</h3>

<p>After tackling all the bugs and features for our first adopter, we
started to consider how best to expose search functionality. To
implement things like search, we generally recommend using the Harmony
Core EF Provider, which eliminates the need for programmer intervention.
In this case, however, we couldn’t use the Harmony Core EF Provider due
to the nature of the project’s file/data layout. A comprehensive search
function was already built into the application, <strong>but we wouldn’t
really be implementing OData if we just exposed custom methods that
didn’t offer any OData query options.</strong> Thus, <strong>the idea for adapters
was born!</strong></p>

<p>The existing search had a particular set of operations, numeric ranges,
field matches, “or field matches”, and arbitrary parameters. These sorts
of operations can be expressed in a single flat data structure, so we
created the dispatch machinery to convert OData queries into a single
class instance and call the requested Synergy method, passing that
instance to it. To maintain high performance when dispatching, we
generated the dispatcher using low-level LINQ expressions to take
advantage of their precompilation features. <strong>This means that Harmony
Core does the complicated task of generating code to map an OData query
to a Synergy data structure the first time the request is made.</strong> After
that, it just runs the compiled code at full speed. This was a bit of a
challenge to implement, but we think it will make web services much more
performant.</p>

<h3 id="repository">Repository</h3>

<p>After the conference, we picked up a few more early adopters, including
several with repositories that hadn’t been used for <em>xf</em>ODBC so they
didn’t have any relations defined. As we worked with these repositories,
we came to realize that <strong>Harmony Core could not describe a two-way
relationship when a tag field was involved.</strong> A tag field is a literal
that indicates record type when multiple record types are stored in a
single ISAM file. Only foreign keys can specify tag literals, but
repositories can’t have foreign-to-foreign key relations, which would
allow for two-way relationships. (Repositories can have only
access-to-access key relations and foreign-to-access key relations.)
After some back and forth on this, we came up with an answer: enhance
CodeGen. CodeGen now looks across relations defined for structures and
glues both foreign keys together in a
foreign-to-access/access-to-foreign key relationship. To do this,
CodeGen uses either the foreign key naming convention or description
fields for the foreign keys.</p>

<p>In addition to fun with foreign keys, we ran into some interesting EF
Core limitations when describing the fields in a join. Synergy allows
keys to be comprised of up to eight segments that can total up to 256
bytes. <strong>EF Core has a loosely similar concept, composite keys.</strong> When
using composite keys to describe a relationship, <strong>however, the parts of
a composite key must have matching types.</strong> This is not a restriction in
Synergy, so we had to figure a way around this limitation. The solution
we came up with was to <strong>add another type of field metadata: composite
fields</strong>. These fields in the generated DataObjectMetadataBase class
allow us to keep track of the size, position, and type of each supplied
key segment, while exposing only a single dummy field to the EF Core
Navigation property.</p>

<p>The work we did to create composite fields in metadata opened up an
additional opportunity. When we introduced Harmony Core at the
conference, it was possible to create calculated fields simply by
defining a property with a getter that returned the data in question
along with a setter that either threw an exception or wrote to the
actual underlying field, depending on your use case. But <strong>Harmony
Core</strong> <strong>didn’t yet understand which fields were required when selecting
a calculated field while using sparse Select with <em>xf</em>Server</strong> for
remote data access. Thanks to composite fields, this is now implemented.
To take advantage of this enhancement, you’ll need to create a property
in your DataObject’s partial class and implement a partial class for its corresponding
DataObjectMetadataBase with a private void method called
InitializeCustomFields. InitializeCustomFields just needs to call
AddFieldInfo (which creates a composite field with the same name as the
calculated field), passing references to the field metadata for each of
the fields required to calculate the field.</p>

<p>Over the past few months, we’ve been polishing our templates, building
out our documentation, and fixing bugs reported by our early adopters.
With all these enhancements, Harmony Core should be a Synergy
developer’s best bet for adding Synergy web services. Still not sure if
this is the right choice for your applications? We’re working on so much
more.</p>

<h1 id="our-plan-going-forward">Our Plan Going Forward</h1>

<p>Because Harmony Core is an open-source project, we want to share not
only our technical roadmap, but also our goals for the project. We also
want to set expectations up front so you can help keep us accountable
and on track.</p>

<p>Technical Direction</p>

<p>There are so many things we can do to extend the Harmony Core framework,
but we’ve chosen a few large items and a smattering of smaller ones to
focus on over the next 12 months. We’ll continue to post blog updates as
features are delivered and the direction evolves.</p>

<h3 id="webhooks">Webhooks</h3>

<p>Webhooks are user-defined HTTP callbacks that are usually triggered by
some event, such as a status update for an order, or when the quantity
of something drops below a certain level. <strong>Webhooks are very useful
when you have to glue two complex systems together.</strong> Imagine your
company has grown by acquisition and you find yourself needing to merge
the underlying data and business functions of two different IT systems.
If you’re trying to build a unified RESTful view of both systems, your
view is going to need to be notified when important events occur in the
underlying system. Webhooks are the best way to do this. We think this
sort of functionality will be crucial in many scenarios. If you have
thoughts about how you would like to use this technology, please post on
<a href="https://github.com/Synergex/HarmonyCore/issues/61" target="_blank" rel="noopener">https://github.com/Synergex/HarmonyCore/issues/61</a>. We aren’t certain
what shape this support will take, but we will be actively pursuing
this. Large (1-3 months)</p>

<h3 id="adapters">Adapters</h3>

<p>While we’ve already implemented adapters, there is so much more we can
do to extend their uses. Currently, adaptors apply only to filters, but
we can further blur the line between operations provided by EF Core and
custom code. This would entail implementing additional attributes to
indicate that a particular field or collection needs to be expanded. In
general, our design philosophy is to flatten OData queries into the sort
of data structures that customers currently use to implement custom
solutions. <strong>Supporting custom Synergy code is a very important part of
Harmony Core</strong>; many of you have decades of very important business
logic that you want to expose to the world. We would be doing you a
disservice if the full OData query experience were not applicable to
your important business logic. <strong>Adaptor enhancements will enable you to
take full advantage of uniform OData query syntax</strong>, whether you’ve
implemented an endpoint with custom code or are using the Harmony Core
EF Provider. See <a href="https://github.com/Synergex/HarmonyCore/issues/85" target="_blank" rel="noopener">https://github.com/Synergex/HarmonyCore/issues/85</a>.
Large (1-2 months)</p>

<h3 id="joins">Joins</h3>

<p>Not all customer data is laid out the way we developers would like it to
be. Sometimes this is for historical reasons, or it might be the result
of business requirements. Whatever the reason, we want to make sure it’s
possible to fully expose your data via OData and EF Core. <strong>This means
we need to add at least some support for nested subqueries.</strong> The main
use case we’re thinking of is when data for different branch locations
is stored in separate files. In order to join across all branches, we
will have to split the query into several parts, storing some
intermediate results in a hash lookup table. While this doesn’t amount
to support for completely arbitrary subqueries, we think it will solve
most customer needs. See
<a href="https://github.com/Synergex/HarmonyCore/issues/83" target="_blank" rel="noopener">https://github.com/Synergex/HarmonyCore/issues/83</a>. Large (1-3 months)</p>

<h3 id="a-migration-path-for-xfserverplus">A Migration Path for <em>xf</em>ServerPlus</h3>

<p>Prior to the conference, we added support for reading <em>xf</em>ServerPlus
method catalogs. We also added initial support for generating the
required wrappers and glue to allow existing <em>xf</em>ServerPlus methods to
be called using the JSON-RPC 2.0 protocol and the Traditional Bridge
portion of Harmony Core. <strong>This needs to be extended to support all the
data types and coercion that exist in the wild.</strong> See
<a href="https://github.com/Synergex/HarmonyCore/issues/84" target="_blank" rel="noopener">https://github.com/Synergex/HarmonyCore/issues/84</a>. Large (1-3 months)</p>

<h3 id="durable-transaction-log">Durable Transaction Log</h3>

<p>At the conference we rhetorically asked, “Is this ACID?” Spoiler alert:
we’re pretty close but not quite all the way there. <strong>The missing piece
of the puzzle is a durable transaction log,</strong> which is really just a
fancy name for an on-disk data structure used as part of a two-phase
commit. As transactions are being committed to the underlying ISAM
files, Harmony Core would write a log of the operations that it’s
performing with information on the state they are in should there be a
hardware or software fault that interrupts ISAM operations. In addition
to its verification duties, the transaction log would also enable us to
undo any changes that were only partially committed. When combined with
innovations at the operating system level (such as Storage Spaces Direct
in Windows Server 2019) and ISAM resiliency in Synergy/DE 11, we think
the transaction log will provide the foundation for highly available,
fault-tolerant Synergy applications and web services. See
<a href="https://github.com/Synergex/HarmonyCore/issues/82" target="_blank" rel="noopener">https://github.com/Synergex/HarmonyCore/issues/82</a>. Large (2-4 months)</p>

<h3 id="tooling-improvements">Tooling Improvements</h3>

<p><strong>CodeGen integration with MSBuild</strong> – We’ve wanted to improve the
process of building projects that use CodeGen templates. The degree to
which we rely on CodeGen templates for Harmony Core projects is
staggering. Keeping generated code up to date should be a build system
operation rather than something for humans to manage (i.e., forget).
Small (1-2 weeks)</p>

<p><strong>CodeGen integration with NuGet</strong> – Delivering updates to CodeGen
templates is tricky and manual. Those are a pair of attributes that
should never be associated with tasks that must be performed frequently.
Our answer to this problem is to ship template (.tpl) files using NuGet
packages. This way, your build system can reference a specific version
number for the templates you’re using. If updates are available, all you
have to do is bump the requested version, and CodeGen will go download
the requested package of templates. Small (1-2 weeks)</p>

<p><strong>.NET CLI scaffolding tool</strong> – The command line interface for .NET
Core introduced a concept known as scaffolding. Rather than shipping
complex logic in wizards, project templates, or item templates, the
dotnet tool allows you to offer a scaffolding generator. Conceptually,
it’s very similar to a wizard in Visual Studio, but it’s much easier to
work with and can be used without Visual Studio. Because Harmony Core
relies heavily on CodeGen templates and source conventions, it’s
currently more difficult than it should be to add new functionality to
an existing project. Once we have a scaffolding tool, it will be much
easier to add new endpoints, new structures, custom code in partial
classes, and wrappers around existing code. Small (1-2 weeks)</p>

<h3 id="concurrency-improvements">Concurrency Improvements</h3>

<p><strong>Multiple <em>xf</em>Server connections</strong> – Currently the Harmony Core EF
provider uses only a single <em>xf</em>Server connection. We need to build
additional infrastructure into the provider to maintain a pool of worker
threads that each have an open <em>xf</em>Server connection. And the
FileChannelManager class will need some additional smarts to deal with
request queuing and to use existing threads with requested channels. See
<a href="https://github.com/Synergex/HarmonyCore/issues/79" target="_blank" rel="noopener">https://github.com/Synergex/HarmonyCore/issues/79</a>. Small (1-2 weeks)</p>

<p><strong>Additional configuration options for FileChannelManager and, more
generally, the pooling mechanisms</strong> – Currently we open file channels
and never close them for the duration of a FileChannelManager object.
This improves the performance of individual requests, but it’s wasteful
in situations where there are hundreds of files, but few that are
commonly accessed. The plan for this is to implement a
least-recently-used (LRU) eviction strategy. Keeping track of the total
list of all files that have ever been opened and the relative frequency
of file opens should allow us to auto-tune the number of channels to
keep in the LRU list. See
<a href="https://github.com/Synergex/HarmonyCore/issues/81" target="_blank" rel="noopener">https://github.com/Synergex/HarmonyCore/issues/81</a>. Small (1-2 weeks)</p>

<p><strong>Traditional Bridge SSH connection multiplexing</strong> – Currently, we open
one SSH connection for each Traditional Bridge process on the remote
server. For a very large number of processes, this is wasteful because
connections are sitting idle most of the time. We can instead create up
to 10 sessions per SSH connection (or more if the operating system is
configured for it), which would enable us to have many more worker
processes without the additional SSH overhead. This would be
configurable for cases where SSH connection scaling isn’t the
bottleneck. See <a href="https://github.com/Synergex/HarmonyCore/issues/80" target="_blank" rel="noopener">https://github.com/Synergex/HarmonyCore/issues/80</a>.
Small (less than 1 week)</p>

<h3 id="better-debugging">Better Debugging</h3>

<p>Diagnosing issues in production is one of the most challenging tasks for
a developer. We’re considering two features to make this less daunting:
per-request logging levels and per-request Traditional Bridge debugging.</p>

<p><strong>Per-request logging levels</strong> – Harmony Core offers extensive logging
along with a logging framework that works well with Synergy data types.
This is great in development, but in production it can destroy
performance or collect sensitive data that shouldn’t be logged. By
providing a custom HTTP header with a request, the logging level could
be set specifically for that request. This means you could get full fat
logging from a production server while the enhanced logging is turned
off for the rest of your requests. See
<a href="https://github.com/Synergex/HarmonyCore/issues/77" target="_blank" rel="noopener">https://github.com/Synergex/HarmonyCore/issues/77</a>. Small (less than 1
week)</p>

<p><strong>Per-request Traditional Bridge debugging</strong> – Similar to per-request
logging levels, we can use custom HTTP headers to cause the current
request to launch a debuggable Traditional Bridge process. This would
cause a separate .dbr and command line to be run on the remote system
for this one request, enabling you to attach a debugger from Visual
Studio to the running remote process, even in a production environment
with thousands of normal requests being serviced concurrently. See
<a href="https://github.com/Synergex/HarmonyCore/issues/78" target="_blank" rel="noopener">https://github.com/Synergex/HarmonyCore/issues/78</a>. Small (less than 1
week)</p>

<h2 id="harmony-core-goals">Harmony Core Goals</h2>

<p>What will determine the success of this project? Ultimately, it will be
you, the customer. So we want to make sure that implementing and
interacting with the web services you build with Harmony Core is as
painless as possible.</p>

<p>For 2019, our goal is to have at least four customers that have
successfully deployed Harmony Core web services or are in the final
stages of developing real-world solutions that make extensive use of
Harmony Core. This is not as aggressive as it sounds; we already have
four customers in various stages of development, and we aren’t just
aiming to get four customers; we want those customers to be happy with
the quality of Harmony Core and with the features it provides. To
determine if these customers are happy, we’ll keep track of the net
promotor score for all the different parts of Harmony Core. For example,
if you have a complaint about the documentation or need more help than
we expected in order to implement something, that’s a sign that we are
missing documentation, examples, educational material, blog posts, or
functionality. We’ll need to hear this from you to know how to do
better. Once an issue is found, we’ll address it and follow up to
determine if the solution actually worked. The number of adopters can’t
and won’t be our only metric for success. Additionally, we anticipate
that we’ll need to interact with non-technical decision makers and
non-Synergy developers who in some cases will know best if Harmony Core
is actually solving their business needs.</p>

<h3 id="open-source-technology-the-new-frontier">Open-Source Technology: The New Frontier</h3>

<p>We feel that open-source development is a two-way street; in order to be
successful, we need non-Synergexian contributors to create pull requests
and issues on GitHub. We’re hoping for at least four non-Synergexian
contributors to submit pull requests or issues by the end of 2019. The
contributions can be for documentation fixes, new samples, or even new
core functionality. We will tag GitHub issues that we think are a good
fit for external contributors. For a non-tagged issue, we would ask that
you give us a heads-up on GitHub to make sure we aren’t currently
working on a solution for the issue. In general, we’re looking to add
features and functionality that will be applicable to the majority of
users, so we won’t want to incorporate code that is specific to a
company or line of business.</p>

<h2 id="what-you-can-expect-from-synergex">What You Can Expect from Synergex</h2>

<p>When it comes to open-source products, Synergex’s stance has generally
been to provide the software as-is with no guarantees. For Harmony Core,
however, you can expect Synergex to provide more robust support.
Although the development path for Harmony Core is different than for our
proprietary products, we want companies of all sizes to feel comfortable
taking such a large dependency on Harmony Core. We think this can be
accomplished using GitHub issues, but we’re looking to you, the Harmony
Core community, to tell us what kind of service-level guarantees your
management team will need.</p>

<h3 id="support">Support</h3>

<p>Our Developer Support team is already training up on Harmony Core, and
we plan to train them to write and understand CodeGen templates. There
are quite a few new areas inside CodeGen that have been added as a
result of the Harmony Core project, and you can expect the support team
to have up-to-date knowledge on those enhancements. We will also begin
looping Support into our ongoing development and deployment efforts with
customers. I believe there is no training substitute for extensive
guidance while getting your hands dirty on the inner workings of a
product, and I think the team will be very well equipped to tackle and
triage Harmony Core support cases in the near future.</p>

<p>In addition to providing help though Developer Support, we’re planning
on incorporating some educational events and materials to ensure that
you can successfully implement and interact with Harmony Core web
services. We will be hosting office hours monthly for anyone interested
in a chance to hop on a GoToWebinar session and ask questions or work
through implementation issues. Office hours are a common feature in
open-source projects run by companies who want make sure complex,
difficult-to-solve issues aren’t ignored or missed or otherwise languish
without solutions. You can also expect regular blog posts recapping the
development progress that has taken place, and we’re interested in
posting project post mortems (with identifying information scrubbed, of
course). We think letting the Harmony Core community see the good, the
bad, and the difficult in project implementation will give developers
and management confidence that they will also be successful.</p>

<h3 id="documentation">Documentation</h3>

<p>Open-source products are usually documented by their creators, and this
will be true of Harmony Core. Our tech writing team will be involved
(organizing, editing, and helping direct the documentation), but all
documentation and samples will come from developers working on Harmony
Core. This is a departure from how documentation has traditionally been
developed at Synergex, but we think this will be the best way to
document this project.</p>

<h2 id="meet-the-harmony-core-team">Meet the Harmony Core Team</h2>

<h3 id="jeff-greene-harmony-core-product-manager">Jeff Greene, Harmony Core Product Manager</h3>

<p><img src="/HarmonyCore/assets/2019-03-22/image2.png" alt="Jeff Greene" style="float:left; padding:10px;" />Jeff joined Synergex in 2006 and he
brought his passion for open source and standards-based technologies
with him.</p>

<p>His first contribution to our product suite was Synergy DBL Integration
for Visual Studio, for which he architected and implemented items
involving Intellisense, debugging, and migration tools. He championed
the importance of running Synergy on .NET Core and was the lead
developer of that project.</p>

<p>Jeff has been instrumental in Synergex’s embrace of Service Oriented
Architecture (SOA) and standards-based technologies. When the need for a
unified solution to creating web services for all Synergy/DE
applications arose, Jeff and Steve Ives created the Harmony Core
Framework with an emphasis on using standardized technologies such as
OData, Swagger, Asp.NET Core, .NET Core and Entity Framework Core.</p>

<p>Jeff has worked with various departments within Microsoft over the
years, and has made significant contributions to the open source
Microsoft CoreRT project.</p>

<h3 id="steve-ives-harmony-core-co-architect">Steve Ives, Harmony Core Co-Architect</h3>

<p><img src="/HarmonyCore/assets/2019-03-22/image3.png" alt="Steve Ives" style="float:left; padding:10px;" />Following an initial background in
operating systems, networking and systems administration early in his
career, Steve realized that his real passion and talent was in the field
of software development.</p>

<p>Having worked for one of the largest Synergy/DE developers in the United
Kingdom, Synergex frequently contracted Steve to present on Synergex
locally in Europe. These engagements consisted of presenting on the
company and products during meetings, delivering training seminars on
the use of the products, and consulting with other customers about how
to address specific technology requirements.</p>

<p>Steve formally joined the Synergex Professional Services group in 1997.
Having held the position of Senior Consultant for over 20 years, Steve
has assisted many Synergy developers to architect, design and implement
a wide variety of software projects. Each of these projects involves
Synergy/DE in some way, and many involve a wide range of other
development languages and technologies.</p>

<p>In recent years, Steve has been a major contributor to several
Synergy-related open source development projects, including:</p>

<ul>
  <li>
    <p>The CodeGen code generator which can be used to automate the
generation of Synergy DBL and other types of code in a wide variety
of software scenarios</p>
  </li>
  <li>
    <p>The SQL Replication reference implementation—this provides a
working example and most of the code needed to replicate a Synergy
application’s ISAM and Relative data to a SQL Server database, in
near-real-time</p>
  </li>
  <li>
    <p>A PDF API that allows Synergy developers to easily add PDF file
creation to their applications</p>
  </li>
  <li>
    <p>The Harmony Core framework which provides Synergy developers the
ability to quickly and easily build RESTful Web Service APIs to
expose their Synergy data and business logic to a wide variety of
applications and environments</p>
  </li>
</ul>

<p>Steve is passionate about assisting software developers to continue to
leverage the investment that they have made in their Synergy code base
over the years, and to continue to see a return on their ongoing
investments in their code.</p>

<h3 id="johnson-luong-harmony-core-developer">Johnson Luong, Harmony Core developer</h3>

<p><img src="/HarmonyCore/assets/2019-03-22/image4.png" alt="Johnson Luong" style="float:left; padding:10px;" />Johnson joined Synergex in 2014 as a QA
engineer. He got his start by testing Synergy releases and the Synergex
Resource Center Community, as well as verifying trackers and automating
the testing of those trackers. You can read about his 
<a href="https://www.synergex.com/installation-authoring-and-testing-techniques/" target="_blank" rel="noopener">testing techniques</a>
and <a href="https://www.synergex.com/testing-testing" target="_blank" rel="noopener">automated testing</a> at Synergex.</p>

<p>In addition, after moving into a software development role, Johnson made
many contributions to our Synergy DBL Integration for Visual Studio
(SDI) product including migrating from WinForms to the WPF property
pages and the product installers from InstallShield to a newer
technology. He has since developed all of our Synergy product installers
with the open-source language, WiX. He worked closely with Fire Giant,
the custodian of WiX, to ensure the Synergy installers are using their
most up-to-date technology.</p>

<p>Prior to joining Synergex, Johnson was an active member of the
Association for Computing Machinery (ACM) at his alma mater. Along with his team, he even won
their biannual International Collegiate Programming Contest. His
background in test along with experience in Visual Studio development
and solid foundational knowledge of algorithm design make Johnson the
perfect addition to round out the Harmony Core team.</p>

  </div><a class="u-url" href="/HarmonyCore/stateofunion/2019/03/22/Harmony-Core-blog.html" hidden></a></article>

      </div>
		<div class="sidenav"><div class="officeHours">
	<h3>Have questions?</h3>
	<p>Join us for office hours hosted via <a href="https://register.gotowebinar.com/register/988880268898103563" target="_blank"  rel="noopener">GoToWebinar</a>. You can drop in to ask our experts your burning questions, get the latest updates, and hear how other customers are implementing Harmony Core in their Synergy applications.
	</p>
	<p style="font-size: 1.2em;">Our next office hours will be on March 4, 8:00 am (PT)</p>
	<center><a class ="call-to-action hoverMiddle" href="https://register.gotowebinar.com/register/988880268898103563" target="_blank" rel="noopener"><div>Sign me up</div></a></center>
</div>
<p>&nbsp;</p>
</div>
	  </div>
    </main><div class="help-call-to-action"><span>Need help?</span> Synergex Professional Services can help you get started.<br />
	<a href="http://synergex.com/consulting/" target="_blank" rel="noopener"><div>See what we can do for you</div></a>
</div>
<footer class="site-footer h-card">
	<data class="u-url" href="/HarmonyCore/"></data>
	<div class="wrapper">
		<div class="footer-col-wrapper">
			<div style="text-align: center;">
				<a href="https://github.com/Synergex/HarmonyCore" target="_blank" rel="noopener">Github</a><br />
				<a href="https://github.com/Synergex/HarmonyCore/wiki" target="_blank" rel="noopener">Wiki</a><br />
				<a href="https://www.youtube.com/playlist?list=PLP_Ryl6KlCA2-SDU7o3wgN2OO9fgaeHnD" target="_blank" rel="noopener">YouTube</a><br />
			</div>
			<div style="width: 50%; float: left;">
				<h2 class="footer-heading">Harmony Core</h2>
			</div>
			<div style="width: 50%; float: right; text-align: right; padding-top: 5px;">
				<a href="https://synergex.com" target="_blank" rel="noopener"><img src="/HarmonyCore/assets/images/Synergex.png" alt="Synergex" rel="noopener"></a>
			</div>
		</div>
	</div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-508059-18"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-508059-18');
</script>

</body>

</html>
